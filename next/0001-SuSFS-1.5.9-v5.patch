From cdac5a427a1b39ca91949580fe9eb7af02ece54e Mon Sep 17 00:00:00 2001
From: deepongi <infectedmushi@gmail.com>
Date: Fri, 5 Sep 2025 14:14:16 +0100
Subject: [PATCH] 0001-SuSFS-1.5.9-v5.patch
---
 kernel/sucompat.c | 248 +++++++++++++++++++++++++++-------------------
 1 file changed, 144 insertions(+), 104 deletions(-)

diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index c58d6293..d44845f4 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -14,6 +14,10 @@
 #include <linux/sched.h>
 #endif
 
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+#include <linux/susfs_def.h>
+#endif
+
 #include "objsec.h"
 #include "allowlist.h"
 #include "arch.h"
@@ -30,7 +34,11 @@ static bool ksu_sucompat_non_kp __read_mostly = true;
 
 extern void escape_to_root();
 
-static void __user *userspace_stack_buffer(const void *d, size_t len)
+static const char sh_path[] = "/system/bin/sh";
+static const char ksud_path[] = KSUD_PATH;
+static const char su[] = SU_PATH;
+
+static inline void __user *userspace_stack_buffer(const void *d, size_t len)
 {
 	/* To avoid having to mmap a page in userspace, just write below the stack
    * pointer. */
@@ -39,9 +47,8 @@ static void __user *userspace_stack_buffer(const void *d, size_t len)
 	return copy_to_user(p, d, len) ? NULL : p;
 }
 
-static char __user *sh_user_path(void)
+static inline char __user *sh_user_path(void)
 {
-	static const char sh_path[] = "/system/bin/sh";
 
 	return userspace_stack_buffer(sh_path, sizeof(sh_path));
 }
@@ -53,77 +60,103 @@ static char __user *ksud_user_path(void)
 	return userspace_stack_buffer(ksud_path, sizeof(ksud_path));
 }
 
-int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
-			 int *__unused_flags)
+// every little bit helps here
+__attribute__((hot, no_stack_protector))
+static __always_inline bool is_su_allowed(const void *ptr_to_check)
 {
-	const char su[] = SU_PATH;
-
+        barrier();
 #ifndef CONFIG_KSU_KPROBES_HOOK
-	if (!ksu_sucompat_non_kp) {
-		return 0;
-	}
+        if (!ksu_sucompat_non_kp)
+                return false;
 #endif
 
-	if (!ksu_is_allow_uid(current_uid().val)) {
-		return 0;
-	}
+#ifndef CONFIG_KSU_SUSFS_SUS_SU
+        if (likely(!ksu_is_allow_uid(current_uid().val)))
+                return false;
+#endif
 
-	char path[sizeof(su) + 1];
-	memset(path, 0, sizeof(path));
-	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
+        if (unlikely(!ptr_to_check))
+                return false;
 
-	if (unlikely(!memcmp(path, su, sizeof(su)))) {
-		pr_info("faccessat su->sh!\n");
-		*filename_user = sh_user_path();
-	}
+        return true;
+}
 
-	return 0;
+static int ksu_sucompat_user_common(const char __user **filename_user,
+                                const char *syscall_name,
+                                const bool escalate)
+{
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+        char path[sizeof(su) + 1] = {0};
+#else
+        char path[sizeof(su)]; // sizeof includes nullterm already!
+#endif
+        if (ksu_copy_from_user_retry(path, *filename_user, sizeof(path)))
+                return 0;
+
+        path[sizeof(path) - 1] = '\0';
+
+        if (memcmp(path, su, sizeof(su)))
+                return 0;
+
+        if (escalate) {
+                pr_info("%s su found\n", syscall_name);
+                *filename_user = ksud_user_path();
+                escape_to_root(); // escalate !!
+        } else {
+                pr_info("%s su->sh!\n", syscall_name);
+                *filename_user = sh_user_path();
+        }
+
+        return 0;
 }
 
-int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
+// sys_faccessat
+int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+                         int *__unused_flags)
 {
-	// const char sh[] = SH_PATH;
-	const char su[] = SU_PATH;
+        if (!is_su_allowed((const void *)filename_user))
+                return 0;
 
-#ifndef CONFIG_KSU_KPROBES_HOOK
-	if (!ksu_sucompat_non_kp){
-		return 0;
-	}
-#endif
+        return ksu_sucompat_user_common(filename_user, "faccessat", false);
+}
 
-	if (!ksu_is_allow_uid(current_uid().val)) {
-		return 0;
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(CONFIG_KSU_SUSFS_SUS_SU)
+struct filename* susfs_ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags) {
+	struct filename *name = getname_flags(*filename_user, getname_statx_lookup_flags(*flags), NULL);
 
-	if (unlikely(!filename_user)) {
-		return 0;
+	if (unlikely(IS_ERR(name) || name->name == NULL)) {
+		return name;
 	}
 
-	char path[sizeof(su) + 1];
-	memset(path, 0, sizeof(path));
-// Remove this later!! we use syscall hook, so this will never happen!!!!!
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0) && 0
-	// it becomes a `struct filename *` after 5.18
-	// https://elixir.bootlin.com/linux/v5.18/source/fs/stat.c#L216
-	const char sh[] = SH_PATH;
-	struct filename *filename = *((struct filename **)filename_user);
-	if (IS_ERR(filename)) {
-		return 0;
+	if (likely(memcmp(name->name, su, sizeof(su)))) {
+		return name;
 	}
-	if (likely(memcmp(filename->name, su, sizeof(su))))
-		return 0;
-	pr_info("vfs_statx su->sh!\n");
-	memcpy((void *)filename->name, sh, sizeof(sh));
-#else
-	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
 
-	if (unlikely(!memcmp(path, su, sizeof(su)))) {
-		pr_info("newfstatat su->sh!\n");
-		*filename_user = sh_user_path();
-	}
+	const char sh[] = SH_PATH;
+	pr_info("vfs_fstatat su->sh!\n");
+	memcpy((void *)name->name, sh, sizeof(sh));
+	return name;
+}
 #endif
 
-	return 0;
+// sys_newfstatat, sys_fstat64
+int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
+{
+        if (!is_su_allowed((const void *)filename_user))
+                return 0;
+
+        return ksu_sucompat_user_common(filename_user, "newfstatat", false);
+}
+
+// sys_execve, compat_sys_execve
+int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
+                               void *__never_use_argv, void *__never_use_envp,
+                               int *__never_use_flags)
+{
+        if (!is_su_allowed((const void *)filename_user))
+                return 0;
+
+        return ksu_sucompat_user_common(filename_user, "sys_execve", true);
 }
 
 // the call from execve_handler_pre won't provided correct value for __never_use_argument, use them after fix execve_handler_pre, keeping them for consistence for manually patched code
@@ -133,15 +166,8 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
 {
 	struct filename *filename;
 	const char sh[] = KSUD_PATH;
-	const char su[] = SU_PATH;
-
-#ifndef CONFIG_KSU_KPROBES_HOOK
-	if (!ksu_sucompat_non_kp) {
-		return 0;
-	}
-#endif
 
-	if (unlikely(!filename_ptr))
+	if (!is_su_allowed((const void *)filename_ptr))
 		return 0;
 
 	filename = *filename_ptr;
@@ -152,9 +178,6 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
 	if (likely(memcmp(filename->name, su, sizeof(su))))
 		return 0;
 
-	if (!ksu_is_allow_uid(current_uid().val))
-		return 0;
-
 	pr_info("do_execveat_common su found\n");
 	memcpy((void *)filename->name, sh, sizeof(sh));
 
@@ -163,41 +186,23 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
 	return 0;
 }
 
-int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
-			       void *__never_use_argv, void *__never_use_envp,
-			       int *__never_use_flags)
-{
-	const char su[] = SU_PATH;
-	char path[sizeof(su) + 1];
-
 #ifndef CONFIG_KSU_KPROBES_HOOK
-	if (!ksu_sucompat_non_kp) {
-		return 0;
-	}
+int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+                        void *envp, int *flags)
+{
+	return ksu_handle_execveat_sucompat(fd, filename_ptr, argv, envp, flags);
+}
 #endif
 
-	if (unlikely(!filename_user))
-		return 0;
-
-	memset(path, 0, sizeof(path));
-	ksu_strncpy_from_user_retry(path, *filename_user, sizeof(path));
-
-	if (likely(memcmp(path, su, sizeof(su))))
-		return 0;
-
-	if (!ksu_is_allow_uid(current_uid().val))
-		return 0;
-
-	pr_info("sys_execve su found\n");
-	*filename_user = ksud_user_path();
-
-	escape_to_root();
-
+// dummified
+int ksu_handle_devpts(struct inode *inode)
+{
 	return 0;
 }
 
-int ksu_handle_devpts(struct inode *inode)
+int __ksu_handle_devpts(struct inode *inode)
 {
+        barrier();
 #ifndef CONFIG_KSU_KPROBES_HOOK
 	if (!ksu_sucompat_non_kp) {
 		return 0;
@@ -214,20 +219,16 @@ int ksu_handle_devpts(struct inode *inode)
 		return 0;
 	}
 
-	if (!ksu_is_allow_uid(uid))
+	if (likely(!ksu_is_allow_uid(uid)))
 		return 0;
 
-	if (ksu_devpts_sid) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
-		struct inode_security_struct *sec = selinux_inode(inode);
+	struct inode_security_struct *sec = selinux_inode(inode);
 #else
-		struct inode_security_struct *sec =
-			(struct inode_security_struct *)inode->i_security;
+	struct inode_security_struct *sec = (struct inode_security_struct *)inode->i_security;
 #endif
-		if (sec) {
-			sec->sid = ksu_devpts_sid;
-		}
-	}
+	if (ksu_devpts_sid && sec)
+		sec->sid = ksu_devpts_sid;
 
 	return 0;
 }
@@ -329,7 +330,8 @@ void ksu_sucompat_init()
 void ksu_sucompat_exit()
 {
 #ifdef CONFIG_KSU_KPROBES_HOOK
-	for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
+	int i;
+	for (i = 0; i < ARRAY_SIZE(su_kps); i++) {
 		destroy_kprobe(&su_kps[i]);
 	}
 #else
@@ -337,3 +339,41 @@ void ksu_sucompat_exit()
 	pr_info("ksu_sucompat_exit: hooks disabled: execve/execveat_su, faccessat, stat, devpts\n");
 #endif
 }
+
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+extern bool ksu_su_compat_enabled;
+bool ksu_devpts_hook = false;
+bool susfs_is_sus_su_hooks_enabled __read_mostly = false;
+int susfs_sus_su_working_mode = 0;
+
+static bool ksu_is_su_kps_enabled(void) {
+	for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
+		if (su_kps[i]) {
+			return true;
+		}
+	}
+	return false;
+}
+
+void ksu_susfs_disable_sus_su(void) {
+	susfs_is_sus_su_hooks_enabled = false;
+	ksu_devpts_hook = false;
+	susfs_sus_su_working_mode = SUS_SU_DISABLED;
+	// Re-enable the su_kps for user, users need to toggle off the kprobe hooks again in ksu manager if they want it disabled.
+	if (!ksu_is_su_kps_enabled()) {
+		ksu_sucompat_init();
+		ksu_su_compat_enabled = true;
+	}
+}
+
+void ksu_susfs_enable_sus_su(void) {
+	if (ksu_is_su_kps_enabled()) {
+		ksu_sucompat_exit();
+		ksu_su_compat_enabled = false;
+	}
+	susfs_is_sus_su_hooks_enabled = true;
+	ksu_devpts_hook = true;
+	susfs_sus_su_working_mode = SUS_SU_WITH_HOOKS;
+}
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_SU
+
-- 
2.51.0

